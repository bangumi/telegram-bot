package main

import (
	"context"
	"html"
	"strconv"
	"strings"
	"time"

	"github.com/grbit/go-json"
	"github.com/mymmrac/telego"
	tu "github.com/mymmrac/telego/telegoutil"
	"github.com/rs/zerolog/log"
	"github.com/segmentio/kafka-go"
)

func (h *handler) processKafkaMessage() error {
	k := kafka.NewReader(kafka.ReaderConfig{
		Brokers: []string{h.config.KafkaBroker},
		GroupID: "tg-notify-bot",
		GroupTopics: []string{
			"debezium.chii.bangumi.chii_pms",
			"debezium.chii.bangumi.chii_notify",
		},
	})

	for {
		msg, err := k.ReadMessage(context.Background())
		if err != nil {
			log.Err(err).Msg("failed to read kafka message")
			continue
		}

		// fake event generated by debezium, ignore it
		if len(msg.Value) == 0 {
			continue
		}

		switch msg.Topic {
		case "debezium.chii.bangumi.chii_pms":
			err = h.handlePM(msg)
		case "debezium.chii.bangumi.chii_notify":
			h.handleNotify(msg)
		}

		if err != nil {
			log.Err(err).Msg("failed to parse kafka message")
		}
	}
}
func (h *handler) handlePM(msg kafka.Message) error {
	return nil
}

func (h *handler) handleNotify(msg kafka.Message) error {
	var dv DebeziumValue
	_ = json.Unmarshal(msg.Value, &dv)
	if len(dv.After) == 0 {
		return nil
	}

	if dv.Source.TsMs-time.Now().UnixMicro() < 60*2*1000 {
		// skip notification older than 2 min
		return nil
	}

	if dv.Op != OpCreate {
		return nil
	}

	var notify ChiiNotify
	_ = json.Unmarshal(dv.After, &notify)

	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()

	// Get the chats for this user
	chats, err := h.getChats(notify.Uid)
	if err != nil {
		return err
	}
	if len(chats) == 0 {
		return nil
	}

	cfg, hasValue := getNotifyConfig(notify.Type)
	if !hasValue {
		log.Warn().Msgf("missing config for type %d", notify.Type)
		return nil
	}

	var field ChiiNotifyField
	err = h.mysql.QueryRowxContext(ctx, "SELECT ntf_id,ntf_hash,ntf_rid,ntf_title from chii_notify_field where ntf_id = %s limit 1",
		notify.Mid).StructScan(&field)
	if err != nil {
		return err
	}

	// Construct URL
	url := strings.TrimRight(cfg.URL, "/") + "/" + strconv.FormatInt(notify.Mid, 10)

	if notify.Mid > 0 {
		url += cfg.Anchor + strconv.FormatInt(notify.Mid, 10)
	}

	text := "<code>" + html.EscapeString(field.NtfTitle) + "</code>"
	if cfg.Suffix != "" {
		text += " " + cfg.Prefix + " <b>" + html.EscapeString(field.NtfTitle) + "</b> " + cfg.Suffix
	} else {
		text += cfg.Prefix
	}

	text += "\n\n" + url

	log.Info().Int64("user_id", notify.Uid).Msg("should send message for notification")

	// Send message to all chats
	for _, chatID := range chats {
		if _, err := h.bot.SendMessage(ctx, tu.Message(tu.ID(chatID), text).WithParseMode(telego.ModeHTML)); err != nil {
			log.Err(err).Int64("chat_id", chatID).Msg("failed to send notification")
		}
	}

	return nil
}

func (h *handler) getChats(userID int64) ([]int64, error) {
	return nil, nil
}
